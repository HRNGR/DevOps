terraform komutları ve işlevleri


# Terraform ile çalışırken sırası ile girilmesi gereken komutlar.
*-* 
    terraform fmt
 ->   terraform init
    terraform validate
 ->   terraform plan
    terraform apply -auto-approve
    terraform destroy -auto-approve
*-* 

## Part-1: Terraform Commands

-  Yeni yapılandırma için bir dizin ("terraform-aws") oluşturun ve dizine geçin.

```bash
mkdir terraform-aws && cd terraform-aws && touch main.tf
```
### Validate command.

- Terminale gidin ve `terraform validate` komutunu çalıştırın. Terraform dosyalarının sözdizimsel olarak doğru ve dahili olarak tutarlı olduğunu doğrular. *.tf dosyasında hatalar varmı kontrol eder. birden fazla .tf dosyalarını tek bir .tf gibi algılar ve ona göre kontrolünü yapar. aynı komuttan birden fazla var ise bizi uyarır.

```bash
terraform validate
```
### fmt command.
`main.tf` dosyasına gidin ve rastgele girintiler ekleyin. Ardından terminale gidin ve `terraform fmt` komutunu çalıştırın. `terraform fmt` komutu, yapılandırma dosyanızı standart stilde yeniden biçimlendirin.

```bash
terraform fmt
```
### terraform console.
- Terminale gidin ve `terraform console` çalıştırın. Bu komut, ifadeleri değerlendirmek ve denemek için etkileşimli bir komut satırı konsolu sağlar. Bu, enterpolasyonları konfigürasyonlarda kullanmadan önce test etmek ve halihazırda durumda kayıtlı olan değerlerle etkileşim kurmak için kullanışlıdır. Kaynakların özniteliklerini tfstate dosyasında görebilir ve yapılandırma dosyanıza yazmadan önce yerleşik işlevleri kontrol edebilirsiniz.

- terraform-aws dizini altında bir dosya oluşturalım ve adını `cloud` verelim ve içinde `hello devops engineers` yazsın.

```bash
echo "hello devops" > cloud
```
- Aşağıdaki komutları çalıştırın.

```bash
terraform console
> aws_instance.tf-ec2
> aws_instance.tf-ec2.private_ip
> min (1,2,3)
> lower("HELLO")
> file("${path.module}/cloud")
> aws_s3_bucket.tf-s3
> aws_s3_bucket.tf-s3.bucket
> exit or (ctrl+c)
```
### show command.

- Terminale git ve `terraform show` komutunu çalıştırın. Terminalde tfstate dosyasını veya planını görebilirsiniz. Daha okunabilir `terraform.tfstate`.

```bash
terraform show
```
### graph command.

- Terminale git ve `terraform graph` komutunu çalıştırın. Terraform kaynaklarının görsel bir grafiğini oluşturur. `terraform graph` komutunun çıktısı, GraphViz tarafından sağlanan nokta kullanılarak kolayca bir görüntüye dönüştürülebilen DOT formatındadır.

- Çıktıyı kopyalayın ve `https://dreampuf.github.io/GraphvizOnline`a yapıştırın. Sonra göster. Bu çıktıyı yerelinizde görüntülemek istiyorsanız, graphviz (`sudo yum install graphviz`) indirebilir ve`terraform graph | dot -Tsvg > graph.svg` komutuyla bir 'graph.svg' alın.

```bash
terraform graph
```
### output command.

- Çıktı değerleri, altyapınız hakkındaki bilgileri komut satırında kullanılabilir hale getirir ve diğer Terraform yapılandırmalarının kullanması için bilgileri açığa çıkarabilir.

- Şimdi aşağıdakileri `main.tf` dosyasına ekleyin. Ardından `terraform apply` veya `terraform refresh` ve `terraform output` komutlarını çalıştırın. 
- `terraform output` komutu, bir durum dosyasından çıktı okumak için kullanılır. Bir Terraform durum dosyasından bir çıktı değişkeni okur ve değeri yazdırır. Ek argüman olmadan çıktı, (ana) kök modül için tüm çıktıları görüntüler. NAME belirtilmezse tüm çıktılar yazdırılır.

- main.tf dosyasının içine bu kodları ekliyoruz.

```bash
output "tf_example_public_ip" {
  value = aws_instance.tf-ec2.public_ip
}

output "tf_example_s3_meta" {
  value = aws_s3_bucket.tf-s3.region
}
```
- kodları ekledikten sonra. sırası ile konutları çalıştırıp sonuçlarına bakalım.

```bash
terraform apply
terraform output
terraform output -json
terraform output tf_example_public_ip
```
### terraform apply -refresh-only command.
- `terraform apply -refresh-only` komutu, durum dosyasını gerçek dünya altyapısıyla güncellemek için kullanılır. Bu, bilinen son durumdan herhangi bir sapmayı tespit etmek ve durum dosyasını güncellemek için kullanılabilir. Öncelikle `terraform state list` ile kaynaklarınızın mevcut durumunu kontrol edin. Ardından AWS konsoluna gidin ve `wolf-tf-test-bucket-addwhateveryouwant` S3 kovanızı silin. Durum listesini tekrar görüntüleyin ve durumu yenileyin. Aşağıdaki komutları çalıştırın.

```bash
terraform state list
```
- kodun alacağı çıktı
    aws_instance.tf-example-ec2
    aws_s3_bucket.tf-example-s3

```bash
terraform apply -refresh-only
```

```bash
terraform state list
```
- kodun alacağı çıktı
    aws_instance.tf-example-ec2

- Artık `terraform.tfstate` ve `terraform.tfstate.backup` dosyaları arasındaki farkları görebilirsiniz. Tfstate dosyasından S3 kovası silinir ancak yedekleme dosyasında S3 kovasını görebilirsiniz.

- `terraform apply -auto-approve` komutunu çalıştırın ve tekrar S3 kovası oluşturun.

```bash
terraform apply -auto-approve
```
- `terraform plan` komutuda kontrol etmek için kodu tekrar çalıştırdığı için `terraform apply -refresh-only` aynı işlemi yapıyor.

> ### Notes: 

- Alt yapıda birşey değiştirilmeyeceği zaman kullanılır hız kazanmak için. Mesela ec2'muzun IP sini öğrenmke istersek gibi.

 `terraform apply -refresh=false` komutunu çalıştırın.

```bash
$ terraform apply -refresh=false
```

## Part 2: Variables.
- Değişkenler, modülün kendi kaynak kodunu değiştirmeden Terraform modüllerinin özelliklerini özelleştirmenize izin verir. Bu, modüllerinizi birleştirilebilir ve yeniden kullanılabilir hale getirerek farklı Terraform konfigürasyonları arasında modülleri paylaşmanıza olanak tanır.
- Yapılandırmanızın kök modülünde değişkenler tanımladığınızda, CLI seçeneklerini ve ortam değişkenlerini kullanarak değerlerini ayarlayabilirsiniz.

### Değişkenleri Bildirme ve Kullanma

- Bir modül tarafından kabul edilen her giriş değişkeni, bir değişken bloğu kullanılarak bildirilmelidir.

- `main.tf` dosyasındaki değişiklikleri yapın.

Örnek;

```bash
variable "ec2_name" {
  default = "compwolf-ec2"
}

variable "s3_bucket_name" {
  default = "compwolf-s3-bucket-variable-addwhateveryouwant"
}
```

### Name tanımlarken veya başka bir değişken tanımlar iken

```bash
ami = var.ec2.ami
Name = "${var.ec2_name}-instance"
```
burada  ${} --> içerisine yazdığımız değişken ismini getirir sonuna -instance eklemesi yapar.

Kodun Sonucu <var.ec2.ami-instance> olarak alınır.

#### Ortam variables
"terraform videosu ders-2 dakikası 01:50"
- Terraform, kendi sürecinin ortamını 'TF_VAR_' adlı ortam değişkenleri ve ardından bildirilen bir değişkenin adı için arar.

- 'TF_VAR_' ile başlayan ortam değişkenleriyle de değişken tanımlayabilirsiniz.

```bash
export TF_VAR_s3_bucket_name=wolf-env-varible-bucket

terraform plan
```

#### Değişken tanımlarında (.tfvars)
##### 1-
- `touch terraform.tfvars` adlı bir dosya adı oluşturun. Aşağıdakileri ekleyin.
```bash
s3_bucket_name = "tfvars-bucket"
```
- Aşağıdaki komutu çalıştırın.
```bash
terraform plan
```
##### 2-
- `compwolf.tfvars` adlı bir dosya adı oluşturun. Aşağıdakileri ekleyin.
```bash
s3_bucket_name = "wolf-tfvar-bucket"
```
- Aşağıdaki komutu çalıştırın.
```bash
terraform plan --var-file="compwolf.tfvars"
```

##### 3-
- `compwolf.tfvars` adlı bir dosya adı oluşturun. Aşağıdakileri ekleyin.
```bash
s3_bucket_name = "wolf-tfvar-bucket"
```
- Aşağıdaki komutu çalıştırın.
```bash
terraform plan --var-file="compwolf.tfvars"
```

##### 4-
- `compwolf.auto.tfvars` adlı bir dosya adı oluşturun. Aşağıdakileri ekleyin.
```bash
s3_bucket_name = "compwolf-auto-tfvar-bucket"
```
- Aşağıdaki komutu çalıştırın.
```bash
terraform plan
```

- Terraform, değişkenleri aşağıdaki sırayla yükler:

   1- Komut satırındaki herhangi bir -var ve -var-file seçenekleri, sağlandığı sırayla.
   2- Herhangi bir *.auto.tfvars veya *.auto.tfvars.json dosyaları, dosya adlarının sözcük sırasına (alfabetik sırayla) göre işlenir.
   3- Varsa terraform.tfvars.json dosyası.
   4- Varsa terraform.tfvars dosyası.
   5- Ortam değişkenleri

- terraform uygulama komutunu çalıştırın.
```bash
terraform apply 
```

#### Locals
- Yerel bir değer bir ifadeye bir ad atar, böylece bir modül içinde tekrarlamadan birkaç kez kullanabilirsiniz.

- `Main.tf` dosyasındaki değişiklikleri yapın.

Örnek
```bash
provider "aws" {
  # Configuration options
  region = "us-east-1"
}

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.0"
        # yukarıdaki komut terraformun en güncen versiyonunu yüklemek için.
    }
  }
}

locals {
  mytag = "compwolf-name"
}

resource "aws_instance" "tf-ec2" {
  ami           = var.ec2_ami
  instance_type = var.ec2_type
  key_name      = "erdogan"
  tags = {
    Name = "${local.mytag}-come from locals"
  }
}

resource "aws_s3_bucket" "tf-s3" {
  bucket = var.s3_bucket_name
  tags = {
    Name = "${local.mytag}-come from locals"
  }
}
```

## Part 3: Conditionals and Loops (Koşullar ve Döngüler)

### count (saymak)
- Varsayılan olarak, bir kaynak bloğu bir gerçek altyapı nesnesini yapılandırır. Ancak bazen, her biri için ayrı bir blok yazmadan birkaç benzer nesneyi (sabit bir bilgi işlem örneği havuzu gibi) yönetmek istersiniz. Terraform'un bunu yapmanın iki yolu vardır: count ve for_each.
örnek: birden fazla ec2 ayağa kaldırmak için count ile daaha kısa kod bloğu sayesinde istediğimiz kadar ec2 ayağa kalkar.

```bash
resource "aws_instance" "tf-ec2" {
  ami           = var.ec2_ami
  instance_type = var.ec2_type
  key_name      = "erdogan" # <pem file>
  count         = 3
  #  count = 3  "aynı özelliklerde birden fazla makine ayağa kaldırmak için kaç adet makine ayağa kaldırmak istiyorsak aynı özelliklerde gitilen sayı kadar makine ayağa kaldırır"
  tags = {
    #    Name = "tf-ec2"
    Name = "${local.mytag}-come-${count.index}"
  }
}
```
- "count" argümanı bir tam sayıyı kabul eder ve kaynak veya modülün o kadar çok örneğini oluşturur. Her örneğin kendisiyle ilişkilendirilmiş ayrı bir altyapı nesnesi vardır ve her biri yapılandırma uygulandığında ayrı ayrı oluşturulur, güncellenir veya yok edilir.

- .tf dosyalarının bulunduğu kalasöre gidin ve yeni bir `variables.tf` değişkeni oluşturun. içinede aşağıda yazılanı yazın.

```t
variable "num_of_buckets" {
  default = 2
}
```
- .tf dosyalarının bulunduğu kalasöre gidin ve yeni bir `main.tf` değişkeni oluşturun. içinede aşağıda yazılanı yazın.

```bash
resource "aws_s3_bucket" "tf-s3" {
  bucket = "${var.s3_bucket_name}-${count.index}"
  count = var.num_of_buckets
}
```
- burada birden fazla değişken olduğu zaman değişken isimlerimiz aynı olmasın diye değişken isimlerimizin sonuna <-${count.index}> ekliyoruz. otomatik değer atasın diye.

### Conditional Expressions (Koşullu İfadeler)

- Koşullu bir ifade, iki değerden birini seçmek için bir boole ifadesinin değerini kullanır.

- `main.tf` dosyasına gidin, değişiklikleri sırayla yapın.

```bash
resource "aws_s3_bucket" "tf-s3" {
  bucket = "${var.s3_bucket_name}-${count.index}"
  # count = var.num_of_buckets
  count = var.num_of_buckets != 0 ? var.num_of_buckets : 3
  # --> yukarıdaki koşul şarta bağlandı. ?=eğer demek. !=0 sıfıra eşitse sol tarafını kullan değilse sağ tarafını kullan.
}
```

### for_each (her biri için)

- for_each meta-argümanı bir haritayı veya bir dizi diziyi kabul eder ve o harita veya kümedeki her öğe için bir örnek oluşturur. Her örneğin kendisiyle ilişkilendirilmiş ayrı bir altyapı nesnesi vardır ve her biri yapılandırma uygulandığında ayrı ayrı oluşturulur, güncellenir veya yok edilir.
- Kısaca `count` dan farklı olarak `for_each` da isim isim gitmesidir.


- `variables.tf` dosyasına tekrar gidin ve yeni bir değişken ekleyin.

```bash
variable "users" {
  default = ["santino", "michael", "fredo"]
}
```
- `main.tf` dosyasına gidin ve değişiklikleri yapın. IAM rolünü değiştirin ve IAMFullAccess politikası ekleyin.

```bash
resource "aws_s3_bucket" "tf-s3" {
  # bucket = "var.s3_bucket_name.${count.index}"
  # count = var.num_of_buckets
  # count = var.num_of_buckets != 0 ? var.num_of_buckets : 1
  for_each = toset(var.users)
  bucket   = "example-tf-s3-bucket-${each.value}"
}

resource "aws_iam_user" "new_users" {
  for_each = toset(var.users)
  name = each.value
}

output "uppercase_users" {
  value = [for user in var.users : upper(user) if length(user) > 6]
}
```
"# --> yukarıdaki komutun açıklaması.
"#  value = [for user in var.users : upper(user) ] komutu, <var.users> da belirtilen isimleri bütün karakterlerini büyük harfle yaz.
"#  value = [for user in var.users : upper(user) if length(user) > 6]
"# --> yukarıdaki komutun açıklaması.
"# komutumuza <if length(user) > 6]> eklediğimizde de <var.users> da belirttiğimiz isimleri 6 ve altıdan büyük olanlarına işlemi uygula diye şart koşuyoruz.

```bash
terraform apply
```

- AWS konsoluna (IAM ve S3) gidin ve kaynakları kontrol edin.


## terraform destroy.
- Tüm altyapıyı silin.

```bash
terraform destroy
```